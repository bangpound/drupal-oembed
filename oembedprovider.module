<?php

/**
 * Implementation of hook_menu().
 */
function oembedprovider_menu() {
  $menu = array();

  $handler = array(
    'type' => MENU_CALLBACK,
    'page callback' => '_oembedprovider_handle_request',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
  );

  $menu['oembed/endpoint'] = $menu['oembed/endpoint/%'] = $handler;

  return $menu;
}

/**
 * Implementation of hook_theme().
 */
function oembedprovider_theme() {
  $themes = array();
  $themes['oembed_node'] = array(
    'function' => 'oembedprovider_theme_oembed_node',
    'arguments' => array(
      'node' => NULL,
    ),
  );
  return $themes;
}

/**
 * Default theme implementation for oembed_node. We just mirror the node_view function
 * and pass everything on to the node template.
 *
 * @param object $node
 * @return string
 *  The html representation of the node
 */
function oembedprovider_theme_oembed_node($node) {
  $node = node_build_content($node, TRUE, FALSE);

  // Set the proper node part, then unset unused $node part so that a bad
  // theme can not open a security hole.
  $content = drupal_render($node->content);
  $node->teaser = $content;
  unset($node->body);

  // Allow modules to modify the fully-built node.
  node_invoke_nodeapi($node, 'alter', TRUE, FALSE);

  return theme('node', $node, TRUE, FALSE);
}

/**
 * Implementation of hook_oembedprovider().
 *
 * @return array
 */
function oembedprovider_oembedprovider() {
  $base_url = url('', array('absolute' => TRUE)) . 'node/*';
  return array(
    $base_url => array(
      'callback' => '_oembedprovider_node_provider',
    ),
  );
}

/**
 * Returns all the registered response formats
 *
 * @return array
 */
function oembedprovider_formats() {
  static $formats;

  if (!$formats) {
    $cache_key = 'oembedprovider:formats';

    if (!$reset && ($cache = cache_get($cache_key)) && isset($cache->data)) {
      $formats = $cache->data;
    }
    else {
      $formats = array(
        'json' => array(
          'mime' => 'text/plain',
          'callback' =>'_oembedprovider_formats_json',
        ),
        'xml' => array(
          'mime' => 'text/xml',
          'callback' =>'_oembedprovider_formats_xml',
        ),
      );
      drupal_alter('oembedprovider_formats', $formats);

      cache_set($cache_key, $formats);
    }
  }

  return $formats;
}

/**
 * Implementation of hook_oembedprovider_formats_alter().
 */
function oembedprovider_oembedprovider_formats_alter($formats) {
  $formats['jsonp'] = array(
    'mime' => 'text/javascript',
    'callback' => '_oembedprovider_formats_jsonp',
  );
}

/**
 * Callback handler for oembed requests.
 *
 * @param string $format
 *  Optional. The response format to use.
 *  Defaults to $_GET['format'] or 'json', in that order.
 */
function _oembedprovider_handle_request($format='') {
  if (empty($format)) {
    $format = empty($_GET['format']) ? 'json' : $_GET['format'];
  }

  // Get the supported formats, and abort if a unsupported format it requested
  $formats = oembedprovider_formats();
  if (!isset($formats[$format])) {
    header('HTTP/1.0 501 Not implemented. Unsupported response format "' . check_plain($format) . '"');
    die;
  }
  $f = $formats[$format];
  header('Content-type: ' . $f['mime']);

  // Check that we got a url
  if (empty($_GET['url'])) {
    header('HTTP/1.0 406 Not acceptable. The url parameter is required.');
    print call_user_func($f['callback'], _oembedprovider_result('rich', array(
      'title' => t('Not acceptable'),
      'error' => 1,
      'html' => t('The url parameter is required'),
    )));
    die;
  }

  $url = $_GET['url'];
  $width = isset($_GET['width']) ? $_GET['width'] : 0;
  $height = isset($_GET['height']) ? $_GET['height'] : 0;

  $matches = array();
  $provider = oembedcore_get_provider($url, $matches);

  if ($provider) {
    $callback = isset($provider['callback']) ? $provider['callback'] : '_oembedprovider_oembed_proxy';
    $data = call_user_func($callback, $provider, $url, $matches);
    print call_user_func($f['callback'], $data);
    exit;
  }
  else {
    header('HTTP/1.0 404 Not found.');
    print call_user_func($f['callback'], _oembedprovider_result('rich', array(
      'title' => t('Not found'),
      'error' => 1,
      'html' => t('Could not find a provider that supports this url'),
    )));
    die;
  }
}

function _oembedprovider_oembed_proxy($provider, $url, $matches) {
  return _oembedprovider_result('rich', array(
    'html' => oembedcore_oembed_fetch($provider, $url, $matches),
  ));
}

function _oembedprovider_result($type, $props) {
  return array_merge(array(
    'type' => $type,
    'version' => '1.0',
    'provider_name' => variable_get('site_name', ''),
    'width' => 0,
    'height' => 0,
  ), $props);
}


/**
 * The default provider to handle nodes
 *
 * @param string $url
 * @param array $matches
 */
function _oembedprovider_node_provider($provider, $url, $matches) {
  $nid = $matches[1];
  $node = node_load($nid);
  $author = user_load(array('uid' => $node->uid));
  return _oembedprovider_result('rich', array(
    'html' => theme('oembed_node', $node),
    'title' => $node->title,
    'author_name' => $author->name,
    'author_url' => url('user/' . $author->uid, array('absolute' => TRUE)),
  ));
}

/**
 * JSONP formatter
 */
function _oembedprovider_formats_jsonp($data) {
  $callback = !empty($_GET['callback']) ? $_GET['callback'] : 'jsonp';
  return sprintf('%s(%s)', $callback, _oembedprovider_formats_json($data));
}

/**
 * JSON formatter
 */
function _oembedprovider_formats_json($data) {
  return json_encode($data);
}

/**
 * XML formatter
 */
function _oembedprovider_formats_xml($data) {
  $doc = new DomDocument('1.0', 'utf-8');
  $oembed = $doc->createElement('oembed');
  $doc->appendChild($oembed);
  foreach ($data as $key => $value) {
    $e = $doc->createElement($key);
    $e->appendChild($doc->createTextNode($value));
    $oembed->appendChild($e);
  }
  return $doc->saveXml();
}