<?php

/**
 * Implementation of hook_menu().
 */
function oembedprovider_menu() {
  $menu = array();

  $handler = array(
    'type' => MENU_CALLBACK,
    'page callback' => '_oembedprovider_handle_request',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
  );

  $menu['oembed/endpoint'] = $menu['oembed/endpoint/%'] = $handler;

  return $menu;
}

/**
 * Implementation of hook_theme().
 */
function oembedprovider_theme() {
  $themes = array();
  $themes['oembed_node'] = array(
    'function' => 'oembedprovider_theme_oembed_node',
    'arguments' => array(
      'node' => NULL,
    ),
  );
  return $themes;
}

/**
 * Default theme implementation for oembed_node. We just mirror the node_view function
 * and pass everything on to the node template.
 *
 * @param object $node
 * @return string
 *  The html representation of the node
 */
function oembedprovider_theme_oembed_node($node) {
  $node = node_build_content($node, TRUE, FALSE);

  $node->links = module_invoke_all('link', 'node', $node, TRUE);
  drupal_alter('link', $node->links, $node);

  // Set the proper node part, then unset unused $node part so that a bad
  // theme can not open a security hole.
  $content = drupal_render($node->content);
  $node->teaser = $content;
  unset($node->body);

  // Allow modules to modify the fully-built node.
  node_invoke_nodeapi($node, 'alter', TRUE, FALSE);

  return theme('node', $node, TRUE, FALSE);
}

/**
 * Implementation of hook_oembedprovider().
 *
 * @return array
 */
function oembedprovider_oembedprovider() {
  $base_url = url('', array('absolute' => TRUE)) . 'node/*';
  return array(
    $base_url => '_oembedprovider_node_provider',
  );
}

/**
 * Returns all the registered providers, or the providers for a specific host.
 *
 * @param string $host
 *  Optional. Supply a hostname if you only want the provider patterns for a specific host.
 * @return array
 */
function oembedprovider_providers($host=NULL) {
  static $providers;

  if (!$providers) {
    $cache_key = 'oembedprovider:providers';

    if (!$reset && ($cache = cache_get($cache_key)) && isset($cache->data)) {
      $providers = $cache->data;
    }
    else {
      $providers = array();
      $modules = module_implements('oembedprovider');
      foreach ($modules as $module) {
        $ps = call_user_func($module . '_oembedprovider');
        foreach ($ps as $pattern => $callback) {
          $host = _oembedprovider_get_host($pattern);
          $regex_pattern = '/' . str_replace('\*', '(.+)', preg_quote($pattern, '/')) . '/';
          $providers[$host][$regex_pattern] = $callback;
        }
      }
      foreach ($providers as $host => &$patterns) {
        uksort($patterns, '_oembedprovider_specificity_compare');
      }
    }

    cache_set($cache_key, $providers);
  }

  if ($host) {
    return isset($providers[$host]) ? $providers[$host] : array();
  }
  return $providers;
}

/**
 * Helper function that compares the length of match expressions.
 */
function _oembedprovider_specificity_compare($a, $b) {
  return strlen($b) - strlen($a);
}

/**
 * Returns all the registered response formats
 *
 * @return array
 */
function oembedprovider_formats() {
  static $formats;

  if (!$formats) {
    $cache_key = 'oembedprovider:formats';

    if (!$reset && ($cache = cache_get($cache_key)) && isset($cache->data)) {
      $formats = $cache->data;
    }
    else {
      $formats = array(
        'json' => array(
          'mime' => 'text/plain',
          'callback' =>'_oembedprovider_formats_json',
        ),
        'xml' => array(
          'mime' => 'text/xml',
          'callback' =>'_oembedprovider_formats_xml',
        ),
      );
      drupal_alter('oembedprovider_formats', $formats);

      cache_set($cache_key, $formats);
    }
  }

  return $formats;
}

/**
 * Implementation of hook_oembedprovider_formats_alter().
 */
function oembedprovider_oembedprovider_formats_alter($formats) {
  $formats['jsonp'] = array(
    'mime' => 'text/javascript',
    'callback' => '_oembedprovider_formats_jsonp',
  );
}

/**
 * Callback handler for oembed requests.
 *
 * @param string $format
 *  Optional. The response format to use.
 *  Defaults to $_GET['format'] or 'json', in that order.
 */
function _oembedprovider_handle_request($format='') {
  if (empty($format)) {
    $format = empty($_GET['format']) ? 'json' : $_GET['format'];
  }

  // Get the supported formats, and abort if a unsupported format it requested
  $formats = oembedprovider_formats();
  if (!isset($formats[$format])) {
    header('HTTP/1.0 501 Not implemented. Unsupported response format "' . check_plain($format) . '"');
    die;
  }
  $f = $formats[$format];
  header('Content-type: ' . $f['mime']);

  // Check that we got a url
  if (empty($_GET['url'])) {
    header('HTTP/1.0 406 Not acceptable. The url parameter is required.');
    print call_user_func($f['callback'], _oembedprovider_result('rich', array(
      'title' => t('Not acceptable'),
      'error' => 1,
      'html' => t('The url parameter is required'),
    )));
    die;
  }

  $url = $_GET['url'];
  $width = isset($_GET['width']) ? $_GET['width'] : 0;
  $height = isset($_GET['height']) ? $_GET['height'] : 0;

  $matches = array();
  $provider = oembedprovider_get_provider($url, $matches);

  if ($provider) {
    $data = call_user_func($provider, $url, $matches);
    print call_user_func($f['callback'], $data);
    exit;
  }
  else {
    header('HTTP/1.0 404 Not found.');
    print call_user_func($f['callback'], _oembedprovider_result('rich', array(
      'title' => t('Not found'),
      'error' => 1,
      'html' => t('Could not find a provider that supports this url'),
    )));
    die;
  }
}

/**
 * Returns the provider for a url.
 *
 * @param string $url
 *  Teh url to get the provider for.
 * @return mixed
 *  A valid callback or FALSE
 */
function oembedprovider_get_provider($url, &$matches) {
  $host = _oembedprovider_get_host($url);
  $providers = oembedprovider_providers($host);

  foreach ($providers as $regex => $callback) {
    if (preg_match($regex, $url, $matches)) {
      return $callback;
    }
  }
  return FALSE;
}

/**
 * A utility function to get the base domain from a url.
 *
 * @param string $uri
 *  The uri to get the domain form
 * @return string
 *  The domain or NULL
 */
function _oembedprovider_get_host($uri) {
  $matches = array();
  if (preg_match('/^https?\:\/\/([^\/]+)/', $uri, $matches)) {
    $matches = preg_split('/\./', $matches[1]);
    $mc = count($matches);
    if ($mc>=2) {
      return $matches[$mc-2] . '.' . $matches[$mc-1];
    }
    else {
      return $matches[0];
    }
  }
  return NULL;
}

function _oembedprovider_result($type, $props) {
  return array_merge(array(
    'type' => $type,
    'version' => '1.0',
    'provider_name' => variable_get('site_name', ''),
    'width' => 0,
    'height' => 0,
  ), $props);
}


/**
 * The default provider to handle nodes
 *
 * @param string $url
 * @param array $matches
 */
function _oembedprovider_node_provider($url, $matches) {
  $nid = $matches[1];
  $node = node_load($nid);
  $author = user_load(array('uid' => $node->uid));
  return _oembedprovider_result('rich', array(
    'html' => theme('oembed_node', $node),
    'title' => $node->title,
    'author_name' => $author->name,
    'author_url' => url('user/' . $author->uid, array('absolute' => TRUE)),
  ));
}

/**
 * JSONP formatter
 */
function _oembedprovider_formats_jsonp($data) {
  $callback = !empty($_GET['callback']) ? $_GET['callback'] : 'jsonp';
  return sprintf('%s(%s)', $callback, _oembedprovider_formats_json($data));
}

/**
 * JSON formatter
 */
function _oembedprovider_formats_json($data) {
  return json_encode($data);
}

/**
 * XML formatter
 */
function _oembedprovider_formats_xml($data) {
  $doc = new DomDocument('1.0', 'utf-8');
  $oembed = $doc->createElement('oembed');
  $doc->appendChild($oembed);
  foreach ($data as $key => $value) {
    $e = $doc->createElement($key);
    $e->appendChild($doc->createTextNode($value));
    $oembed->appendChild($e);
  }
  return $doc->saveXml();
}